%
% File emnlp2020.tex
%
%% Based on the style files for ACL 2020, which were
%% Based on the style files for ACL 2018, NAACL 2018/19, which were
%% Based on the style files for ACL-2015, with some improvements
%%  taken from the NAACL-2016 style
%% Based on the style files for ACL-2014, which were, in turn,
%% based on ACL-2013, ACL-2012, ACL-2011, ACL-2010, ACL-IJCNLP-2009,
%% EACL-2009, IJCNLP-2008...
%% Based on the style files for EACL 2006 by 
%%e.agirre@ehu.es or Sergi.Balari@uab.es
%% and that of ACL 08 by Joakim Nivre and Noah Smith

\documentclass[11pt,a4paper]{article}
\usepackage[hyperref]{emnlp2020}
\usepackage{times}
\usepackage{latexsym}
\renewcommand{\UrlFont}{\ttfamily\small}

% This is not strictly necessary, and may be commented out,
% but it will improve the layout of the manuscript,
% and will typically save some space.
\usepackage{microtype}

\usepackage{mystyle}
\usepackage{subcaption} 

% trellis
\usepackage{tikz}%

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{pgfplots}

%% ADD BACK!!!!!!!!!!!!!!!!!
%\aclfinalcopy % Uncomment this line for the final submission
%\def\aclpaperid{***} %  Enter the acl Paper ID here

%\setlength\titlebox{5cm}
% You can expand the titlebox if you need extra space
% to show all the authors. Please do not make the titlebox
% smaller than 5cm (the original size); we will check this
% in the camera-ready version and ask you to change it back.

\newcommand\BibTeX{B\textsc{ib}\TeX}
\newcommand\Emit{\mathbf{O}}
\newcommand\Trans{\mathbf{T}}

\title{Scaling Hidden Markov Language Models}

\author{Who Me \\
  Affiliation / Address line 1 \\
  Affiliation / Address line 2 \\
  Affiliation / Address line 3 \\
  \texttt{email@domain} \\\And
  No You \\
  Affiliation / Address line 1 \\
  Affiliation / Address line 2 \\
  Affiliation / Address line 3 \\
  \texttt{email@domain} \\}

\date{}

\begin{document}
\maketitle
\begin{abstract}
The hidden Markov model (HMM) is a fundamental tool for sequence modeling that 
cleanly separates the hidden state from the emission structure.
However, this clean separation makes HMMs difficult to fit to large datasets in modern NLP, 
and they have fallen out of use due to very poor performance 
compared to fully observed models. This work revisits the challenge of 
scaling HMMs to language modeling datasets, taking ideas from recent approaches to neural modeling.
We propose methods for scaling HMMs to massive state spaces, while maintaining compact parameterization, effective regularization, and efficient exact inference. Experiments show that this approach leads to models that are much more accurate than previous HMMs and ngram-based methods while nearing the performance of NN models. 
\end{abstract}

\section{Introduction}


% Hidden Markov models are classic models that have been abandoned.
Hidden Markov models (HMMs) are a fundamental latent-variable model for sequential data.
%They are core to time-series problems in bioinformatics, reinforcement learning, and,
%of course, natural language processing.
Historically they have been used extensively in NLP for tasks such as
sequence modeling \citep{rabiner1990tut}, alignment \citep{vogel1996hmm},
and even, in a few cases, to language modeling \citep{kuhn1994hmmlm,huang2011thesis}. 
Compared to other approaches for sequence models, HMMs are naturally appealing since they 
fully separate out the process of sequential memory from the process of generation, while allowing for 
exact posterior inference. 

%MMs remain an appealing modeling tool that separates out the facets of discrete model memory from
%the generation of observations. 

%In recent years, most models in 
%For the task of language modeling,
%HMMs were explored in work by \citet{kuhn1994hmmlm,huang2011thesis}
%but were not revisited until recently \citep{krakovna2016hmm,dedieu2019learning}.

State-of-the-art systems in NLP have moved away from utilizing latent hidden states
and toward deterministic deep neural models.
We take several lessons from the success of deep neural models for NLP tasks:
(a) the right factorization is critically important for representation learning, e.g. a feedforward model \cite{bengio2003nlm}
can have the same probabilistic structure as an n-gram model while performing significantly better;
(b) overparameterization is critical for finding better local optima,
e.g. overly large LSTMs \cite{zaremba2014lstm} show marked improvements in performance;
(c) regularization choices are necessary to find good solutions for different model parameterizations,
e.g. experiments by \citet{merity2017awdlstm} outline a variety of training choices.

We revisit HMMs for language modeling,
positing that competitive performance may require very large models. 
%To scale to large state-spaces,
%we need scalable parameterizations, efficient inference, and  effective regularization.
We develop a neural parameterization for HMMs that extends 
them to comparable size and structure of deep models.
We combine this parameterization with a modeling constraint that allows us to
utilize HMMs with large state spaces, while maintaining efficient exact inference.
Finally we incorporate a variant of dropout that both improves accuracy
and reduces the computational overhead by an order of magnitude during training. 

Experiments employ HMMs on two language modeling datasets. We find that our HMM extension significantly outperforms past HMMs as well as n-gram models. 
It also performs comparably to neural counterparts with a similar number of parameters
while maintaining uncertainty over the state dynamics.

\section{Related Work}
\label{sec:rw}

Several recent papers have combined HMMs with 
neural networks. \citet{buys2018hmm}
develop an approach to relax HMMs,
but show results that either perform poorly or require altering the probabilistic structure
to look more like an RNN. 
\citet{krakovna2016hmm} utilize model combination with an RNN to connect both approaches in a
20 state model.
We demonstrate how to scale to orders of magnitude more states and show stronger performance.

% Prior work has tried neural parameterizations, but with small state spaces.
Prior work has considered neural parameterization of structured generative models. 
For HMMs, \citet{tran2016hmm} demonstrate improvements in POS induction with a
neural parameterization of an HMM. Other work has used neural parameterization for models, such as 
dependency models \citep{han2017dependency},
hidden semi-Markov models \citep{wiseman2018hsmm},
and context free grammars \citep{kim2019cpcfg}.
These works use latent variables with relatively small state spaces,
as the goal of both was structure induction rather than language modeling.
%We extend the neural parameterization with the aim of supervised modeling.

% Prior work has tried large state spaces with scalar parameterizations.
\begin{comment}
We also draw inspiration from the experiments with
cloned HMMs by \citet{dedieu2019learning},
who propose to introduce sparsity constraints in scalar
emission distribution of HMMs in order to make conditional inference
tractable in large state spaces.
They train a 30k state HMM on character-level language modeling
by constraining every state to emit only a single character type.
This particular constraint is problematic for language modeling at the word level,
where the vocabulary size is much larger.
We build on their work by proposing a sparsity constraint based on
Brown clustering \citep{brown1992} which allows us to extend their
work to vocabularies that are larger than the state space.
\end{comment}


% State splitting / refinement
Finally, another approach to scaling to larger state spaces is to initialize
with a small state space then grow the state space via a split-merge process
\citep{petrov2006splitmerge,huang2011thesis}.
In particular, \citet{huang2011thesis} learn an HMM for language modeling
via this process.
%Additionally, the cloned HMM \citep{dedieu2019learning} can be seen
%as an HMM that starts with a single state per word,
%then splits every state into $k$ states at the start
%with no subsequent splits or merges.
Fixed-size state spaces are significantly easier to optimize for 
current hardware, e.g. GPUs, we therefore leave split-merge
procedures for future work. 

%There are also extensions of HMMs, such as factorial HMMs \cite{zoubin1997fhmm,nepal2013fhmm}
%and context free grammars \citep{kim2019cpcfg}.
%We leave scaling more expressive models to large state spaces for future work,
%and focus on scaling the basic HMM.

\begin{comment}
\begin{figure}[t]
\centering
\begin{tikzpicture}[]
\node[latent] (z0) {$z_0$} ;
\node[latent] (z1) [right=1.25cm of z0] {$z_1$} ;
\node[latent] (z2) [right=1.25cm of z1] {$z_2$} ;
%\node (dots) [right=1.25cm of z2] {$\cdots$} ;
%\node[latent] (zt) [right=1.25cm of dots] {$z_T$} ;

\node[obs]    (x0) [below = 0.75cm of z0] {$x_0$};
\node[obs]    (x1) [below = 0.75cm of z1] {$x_1$};
\node[obs]    (x2) [below = 0.75cm of z2] {$x_2$};
%\node (adots) [right=1.25cm of x2] {$$} ;
%\node[latent] (xt) [right=1.25cm of adots] {$x_T$} ;

\edge {z0} {x0};
\edge {z1} {x1};
\edge {z2} {x2};
\edge {z0} {z1};
\edge {z1} {z2};
%\edge {z2} {zt};
%\edge {dots} {zt};

\end{tikzpicture}

\caption{
\label{fig:hmm}
An HMM with tokens $x_t$ and states $z_t$.
}
\end{figure}
\end{comment}

\section{Background: HMMs}

We are interested in learning a distribution over observed tokens
$\bx = \langle x_1, \ldots, x_T \rangle$, with each token $x_t$
an element of the finite vocabulary $\mcX$.
Hidden Markov models (HMMs) specify a joint distribution over 
observed tokens $\bx$ and discrete latent states $\bz = \langle z_1, \ldots, z_T \rangle$,
with each $z_t$ from finite set $\mcZ$.
For notational convenience, we define the starting state $z_0=\epsilon$.
This yields the joint distribution
\begin{equation}
p(\bx, \bz; \theta)
= \prod_{t=1}^T p(x_t\mid z_t)p(z_t \mid z_{t-1})
\end{equation}
\noindent The distributions are parameterized as follows
\begin{equation}
\label{param}
%p(z_1 | z_0) &\propto e^{\psi_{z_1}}\\
 p(z_t \mid z_{t-1}) \propto e^{\psi_{z_tz_{t-1}}} \; \ p(x_t \mid z_t) \propto e^{\phi_{x_tz_t}}
\end{equation}
with  transitions $\psi \in \mathbb{R}^{|\mcZ|\times|\mcZ|}$
and  emissions $\phi \in \mathbb{R}^{|\mcX| \times |\mcZ|}$.
We refer to emissions $p(x_t \mid z_t)$ as $\mathbf{O}$.

We distinguish two types of parameterizations: \textit{scalar} and \textit{neural}.
A scalar parameterization simply uses $\theta = \set{\phi,\psi}$ to fit one model parameter for
each distributional parameter ($O(|\mcZ|^2 + |\mcX||\mcZ|)$ model parameters). A neural parameterization uses $\theta$ as parameters of a neural network
that generates $\phi$ and $\psi$, which allows for factorization. 

In order to fit an HMM to data $\bx$,
we must marginalize over the latent states to obtain the likelihood
$p(\bx) = \sum_{\bz}p(\bx,\bz)$.
This sum can be computed in time $O(T|\mcZ|^2)$ via dynamic programming,
which becomes prohibitive if the number of latent states $|\mcZ|$ is large.
We can then optimize the likelihood 
with gradient ascent (or alternative variants of expectation maximization).

\noindent \textbf{HMMs and RNNs}
Recurrent neural networks (RNNs) do not attempt to decouple the latent dynamics from the observed.
This often leads to improved accuracy,
but does not allow for posterior inference or for directly incorporating additional
state information. We consider these inherently interesting properties worth exploring as alternatives.
A further benefit of HMMs is that, unlike RNNs,
their associative structure allows for parallel inference
via the prefix-sum algorithm \cite{ladner1980prefix}.\footnote{Quasi-RNNs \citep{bradbury2016qrnn} also have a logarithmic dependency on $T$
by applying the same prefix-sum trick, but do not model uncertainty over
latent dynamics.}

\section{Scaling HMMs}
\label{sec:methods}

\begin{figure}[t]
\centering
\includegraphics[height=1.7in]{img/mat.pdf}
\caption{\label{fig:emit}
The emission matrix as a set of blocks $\mathbf{O}_1, \ldots, \mathbf{O}_4$ (shown in transpose). Each active cell is constructed from word, state, and block embeddings. 
}
\end{figure}

\begin{figure}[!t]
\begin{center}
\input{img/trellis.tex}
\end{center}
\caption{
\label{fig:trellis}
HMM search space with block emissions and state dropout.
}
\end{figure}

\noindent
\textbf{Blocked Emissions} Efficiency of marginal inference inherently limits 
the state space of general HMMs.
However, we can improve inference complexity in special cases.
For instance, inspired by cloned HMMs \citep{dedieu2019learning}
if we know that the probability of emitting a word $x_t$ from a state $z_t$ is 0,
i.e. $p(x_t \mid z_t) = 0$  then we can ignore transitions into and from that state during inference. 

We enforce a stronger constraint that our HMMs have rectangular fixed-width blocked emissions,
\[\mathbf{O} = \begin{bmatrix} \mathbf{O}^1 & 0 & 0 \\ 0 & $\dots$ & 0 \\ 0 & 0 & \mathbf{O}^M \\
\end{bmatrix}\]
where each $\mathbf{O}_m \in \mathbb{R}^{ {\cal X}_m \times |{\cal Z}|/M}$ is a partition indicating which tokens ${\cal X}_m$ can be emitted by states $m|{\cal Z}|$ through $(m+1)|{\cal Z}|$. Conversely let $\mcZ_x \subset {\cal Z}$ be the states with non-zero probability of emitting $x$. Exact marginalization can be computed as 
\begin{equation}
\label{eqn:sparse_marginalization}
\begin{aligned}
p(\bx) &= \sum_{z_1 \in \mcZ_{x_1}} p(z_1\mid z_0)p(x_1 \mid z_1) \times\\
    &\cdots
    \sum_{z_T \in \mcZ_{x_T}} p(z_T \mid z_{T-1})p(x_T \mid z_T)
\end{aligned}
\end{equation}
This gives a serial complexity of $O(T(|Z|/M)^2)$

\vspace{0.2cm}

\noindent
\textbf{Factored Neural Parameterization} Even with blocked emissions, the scalar parameterization of an HMM grows quadratically
with states.
We instead employ a neural parameterization.
The approach is to embed each state in $\cal Z$ ($\mathbf{E}_z \in \mathbb{R}^{|\mcZ| \times h/2}$),
each token in $\cal X$ ($\mathbf{E}_x \in \mathbb{R}^{|\mcX| \times h}$),
and each block ($\mathbf{E}_m \in \mathbb{R}^{M \times h/2}$).
From these we can create representations for leaving a state, entering a state,
and emitting a word: 
\[ \mathbf{H}_{\textrm{out}},\mathbf{H}_{\textrm{in}},\mathbf{H}_\textrm{emit}
 = \text{MLP}(\mathbf{E}_m, \mathbf{E}_z ) \] 
The HMM distributional parameters are given by,
\begin{equation}
\begin{aligned}
\phi = \mathbf{E}_x \mathbf{H}_\textrm{emit}^\top \;\; 
\psi = \mathbf{H}_\textrm{out} \mathbf{H}_\textrm{in}^\top
\end{aligned}
\end{equation}
where $\phi \in \mathbb{R}^{|X|\times|Z|}$ and
$\psi \in \mathbb{R}^{|Z|\times|Z|}$.
The MLP architecture follows \cite{kim2019cpcfg}.
Please refer to the supplementary material for details. 
This neural parameterization takes $O(h^2 + h|\mcZ| + h|\mcX|)$ parameters (shown in Figure~\ref{fig:emit})


Note that parameter computation is independent of inference and can be cached completely at test-time.
%The clean separation between the computation of the distributional parameters and marginal inference
%allows the distributional parameters to be computed and then cached for use in inference.
For training, we compute them once per batch (shown in Alg~\ref{fig:algo}). 
For RNNs and similar models, %transition activations 
emissions must be recomputed for each token. 


\begin{algorithm}[t]
\begin{algorithmic}
\State{Given: block structure and model parameters}
%\Function{ComputeLikelihood}{}
%    \State{Compute parameters $\phi,\psi$ from model parameters}
%    \ForAll{examples $\bx$}
%        \State{Compute log potentials $\Phi = \Call{LogPotentials}{\phi,\psi,\bx,\mcC_x}$}
%        \State{Compute evidence $\log p(\bx) = \Call{Forward}{\Phi}$}
%    \EndFor
%\EndFunction
    \State{Sample block-wise dropout mask $\bb$}
    \State{Compute $\phi,\psi$ ignoring $b_z = 0$}
    \ForAll{batch examples $\bx$}
        \State{ $\Phi = \Call{LogPotentials}{\phi,\psi,\bx,\bb}$}
        \State{$\log p(\bx) = \Call{Forward}{\Phi}$}
    \EndFor
    \State{Update embeddings $\mathbf{E_z, E_x, E_\pi}$ }
\begin{comment}
\Function{LogPotentials}{}
    \State{Given sequence $\bx = \langle x_1,\ldots,x_T \rangle$,
    constraints $\mcC_x$ with $|\mcC_x| = k$,
    transition parameters $\psi$,
    and emission parameters $\phi$}
    \State{Initialize $\Phi \in \mathbb{R}^{T \times k \times k} = 0$}
    \ForAll{$t\in \set{1,\ldots,T}$}
        \State{Set $\Phi[t,:,:] += \psi[x]$}
        \State{Set $\Phi[t,:,:] += \psi[x]$}
    \EndFor
    \State \Return meh \Comment{$O(1)$}
\EndFunction
\Function{Forward}{}
    \For{meh}
        \State{meh}
    \EndFor
    \State \Return meh \Comment{$O(1)$}
\EndFunction
\end{comment}
\end{algorithmic}
\caption{
\label{fig:algo}
HMM Training
}
\end{algorithm}

\vspace{0.2cm}

\noindent
\textbf{Dropout as State Reduction}
To encourage generalization through distributed state usage, we introduce dropout to the model. 
We propose a form of HMM state dropout that removes states from use entirely,
which has the added benefit of speeding up inference.

%This forces the model to use different states while also leading to efficiency improvements
%for computing parameterization and inference. 

%Recall distributional parameters of the emission matrix
%$\phi \in \mathbb{R}^{|\mcX|\times|\mcZ|}$
%and the emission sparsity constraints which associate each token $x$
%with a set of states $\mcC_x$.

State dropout acts on each emission block $\mathbf{O}_1 \ldots \mathbf{O}_M$ independently.
Recall each block has $|{\cal Z}| / M$ columns.
For each, we sample a binary dropout mask by sampling
$ \lambda \times(|{\cal Z}| / M)$ dropped row indices uniformly without replacement.
We concatenate these to a global vector $\mathbf{b}$, which, along with the previous constraints,  ensures,
\begin{equation}
\label{eqn:state_dropout}
p(x \mid z) \propto b_{z}1(z \in \mcZ_x)e^{\phi_{xz}}
\end{equation}
State dropout gives a large practical speed up for both parameter computation and inference.
For $\lambda=0.5$ we get a $4\times$ speed improvement for both,
due to reduction of possible transitions.
This structured dropout is also easier to exploit on GPU,
since it maintains block structure with fixed-height (as shown in Figure~\ref{fig:trellis}).


%Performing marginal inference with state dropout allows us to skip states that are removed 

%Additionally, we do not need to compute the parameters of the
%transition and emission distributions that have been dropped. 
%This reduces the cost of computing $\phi$ and $\psi$ from
%$O(|\mcZ|^2+|\mcZ||\mcX|)$ to $n^2 + n|\mcX|$.


%We utilize the constraint sets induced by $\pi$ and $\rho$
%to ensure that exactly $n$ states remain in each constraint set $\mcC_x$ after applying dropout.
%This is accomplished by subsampling $n$ states from each partition in the preimage of $\pi$,
%which preserves the block structure observed in Fig.~\ref{fig:trellis}
%and allows the number of outgoing edges at each timestep to remain equal to $n$.

%requires $O(Tn^2)$ computation,
%where $n = \max_x \left|\set{z:b_z=1,z \in \mcC_x}\right|$.


%Although a neural parameterization has empirically been shown to find good optima,
%it requires that the distributional parameters be %recomputed every time the
%model parameters are updated.
%This entails running a neural network $O(|\mcZ| + |\mcX|)$ times 
%at every iteration of gradient descent.


\section{Experimental Setup}
\label{sec:experiments}
%In this section we provide further details on the application
%of the methods described in the previous section
%to word-level language modeling,
%where the tokens $\bx$ correspond to the words
%$\bw = \langle w_1,\ldots,w_T \rangle$ in a sentence.
%We thus learn a model over words and states
%$p(\bw,\bz) = \prod_t p(w_t\mid z_t)p(z_t \mid z_{t-1})$.

\textbf{Emission Blocks}
The model requires partitioning token types into blocks $\mcX_m$. 
While there are many partitioning methods, a natural choice
is Brown clusters \citep{brown1992,liang2005brown} also based on HMMs.
Brown clusters are obtained by assigning every token type in $\mcX$ a state in a HMM,
then states are merged until a desired number of partitions $M$ is reached.
We construct the Brown clusters on the training portions of the datasets.


\noindent \textbf{Datasets}
We evaluate on the \texttt{Penn Treebank} \citep{ptb} (929k train tokens, 10k vocab)
and \texttt{wikitext2} \citep{wikitext} (2M train tokens, 33k vocab) datasets.
For \texttt{Penn Treebank} we use the preprocessing from \citet{mikolov-2011},
which lowercases all words and substitutes words outside of the vocabulary with unks.  For \texttt{Wikitext2}  casing is preserved, and all words outside the vocab are replaced with the unk token.
%Both datasets contain inter-sentence dependencies,
%due to the use of documents consisting of more than a single sentence.

\noindent \textbf{Baselines}
Baselines include AWD-LSTM \citep{merity2017awdlstm};
a 900-state scalar HMM and HMM+RNN extension,
which discards the latent variable formulation \citep{buys2018hmm};
a KN 5-gram model \citep{mikolov2012rnn,kenlm},
a 256 dimension FF model,
and a 2-layer 256 dimension LSTM.
We compare these models with our very large HMM (VL-HMM, $|\mcZ|=2^{15}$) that considers 256 latent states at every timestep at test time. See the supplementary for the hyperparameters for all models.

\begin{comment}
\paragraph{Implementation}
We train two-layer LSTM recurrent neural networks with 256 units,
as well as two-layer feed-forward neural networks with 256 units.
The HMMs we train follow the sparsity constraints outlined in the previous
section with a dropout rate of 0.5,
and we vary the total number of states as well as states per word.
We optimize all models with AdamW \citep{adamw}.

We experimented with a couple batching strategies:
On \texttt{Penn Treebank},
the first strategy discarded the inter-sentence dependencies and shuffled all sentences,
and the second treated the corpus as a single flat document without shuffling.
On \texttt{Wikitext2}, we either shuffled at the document level or treated the corpus as a
single document.
Prior work on both corpuses treated the corpora as single documents.

See supplementary material for the hyperparameters for all models.

\end{comment}
\begin{table}[!t]
\centering
\begin{tabular}{llrr}
\toprule
Model & Size & Val  & Test \\
\midrule
\texttt{Penn Treebank}\\
\midrule
KN 5-gram   & 2M & - & 141.2\\
AWD-LSTM  & 24M & 60.0 & 57.3\\
256 FF 5-gram  & 2.9M     & 159.9      & 152.0  \\
2x256 dim LSTM  & 3.6M     & 93.6       & 88.8   \\
HMM+RNN   & 10M & 142.3 & -\\
HMM ($|\mcZ|$=900) & 10M & 284.6 & -\\
VL-HMM ($|\mcZ|=2^{15}$)   & 7.7M     & 125.0      & 115.8  \\
\midrule
\texttt{WikiText}\\
\midrule
KN 5-gram & 5.7M       & 248.7 & 234.3\\
AWD-LSTM & 33M & 68.6 & 65.8\\
256 FF 5-gram        & 8.8M    & 210.9  & 195.0\\
2x256  LSTM     & 9.6M    & 124.5  & 117.5\\
%32k state HMM (no fac)   & 17.3M   & 166.7  & -\\
VL-HMM ($|\mcZ|=2^{15}$)           & 13.7M   & 169.0      & 158.2\\
\bottomrule
\end{tabular}
\caption{\label{tbl:ppl}
Perplexities on the \texttt{PTB / Wikitext-2}.
}
\end{table}


\section{Results}
%\subsection{Language Modeling}
% Tone: Made a lot of progress, and there is even more room for improvement.
% Main avenue for improvement: emission constraints.
Table \ref{tbl:ppl} gives the main results. On \texttt{PTB}, VL-HMM is able achieve 115.8 perplexity on the test set, outperforming a strong 5-gram baseline which obtained a perplexity of 141.2 and vastly outperforming a vanilla HMM  from \citet{buys2018hmm}.
The VL-HMM also outperforms the HMM+RNN extension of \citet{buys2018hmm}. These results indicate that HMMs are a much stronger model on this benchmark than previously claimed.
However, we do find that the HMM is outperformed by LSTM-based models.
This trend persists in \texttt{Wikitext-2},
with the HMM outperforming the 5-gram model at 158.2
and 210.9 perplexity, while an LSTM achieves 117.5.


Fig.~\ref{tbl:states-ablation} examines the effect of state size.
We find that performance continuously improving significantly as we grow to $2^{16}$ states.
Table~\ref{tbl:dropout-param-ablation} considers other ablations.
We find that state dropout results in both an improvement in perplexity,
 a large improvement in time per epoch, and a reduction in training/val performance gap.
%State dropout greatly reduces the gap between training and validation performance, highlighting the effectiveness of state dropout as regularization.
The scalar parameterization has a massive number of model parameters at 423M, compared to the
neural parameterization with 5.6M parameters.
Although both parameterizations reach similar training perplexity,
the neural model generalizes better on validation.

\begin{figure}[!t]
\centering
\begin{tikzpicture}
\begin{axis}[
    xlabel=$|\mcZ|$,
    ylabel=PPL,
    xmode=log,
    log basis x={2},
    xtick={},
    width=7cm,
    height=5cm
]
  \addplot plot coordinates {
    (1024,  213.25)
    (2048,  199.98)
    (4096,  169.18)
    (8192,  150.22)
    (16384, 135.79)
    (32768, 125.02)
    (65536, 121.93)
};
\end{axis}
\end{tikzpicture}
\caption{\label{tbl:states-ablation}
Perplexity on \texttt{PTB} by state size $|\mcZ|$ ($\lambda =0.5$ and $M=128$).
}
\end{figure}


\begin{table}[!t]
\centering
\begin{tabular}{llrrr}
\toprule
Model                           & Size & Train  & Val  &  Time \\
\midrule
VL-HMM ($2^{14}$)       & 5.6M       & 122    & 136  & 159\\
\quad - dropout              & 5.6M       & 89     & 145  & 363\\
\quad - block emb & 7.2M     & 115    & 134  & 142\\
\quad - neural param & 423M  & 119    & 169 & 520
\\
\bottomrule
\end{tabular}
\caption{\label{tbl:dropout-param-ablation}
Ablations on \texttt{PTB} ($\lambda =0.5$ and $M=128$). 
Time is seconds per epoch (Run on RTX 2080).
}
\end{table}


\section{Conclusion}
This work demonstrates that scaling HMMs to large states spaces results in gains in performance.
We introduced three contributions: a blocked emission constraint, a neural parameterization,
and state dropout. These contributions lead to an HMM that outperforms n-gram models and prior HMMs.
This work demonstrates the classical probabilistic models can scale on modern hardware and are
interesting option for fitting NLP datasets. 

% \footnote{The scalar parameterization should be faster per epoch than the
% neural parameterization. We attribute this slowdown
% to the speed of indexing in PyTorch.
% When working with dropout
% the neural parameterization computes subsets
% of $\phi$ and $\psi$ lazily via a matmul,
% whereas the scalar parameterization already has $\phi$ and $\psi$
% available but must index into them to obtain the
% un-dropped values.}


\bibliographystyle{acl_natbib}
\bibliography{anthology,emnlp2020}

\appendix

\section{Hyperparameters}
\label{sec:hyperparams}
For \texttt{Penn Treebank} and \texttt{Wikitext-2}, we trained the following baselines:
a two layer feedforward 5-gram model and a two layer LSTM.
The feedforward model is given by the following:
\begin{equation}
\begin{aligned}
p(w_t \mid \bw_{<t})
&= W_x\textrm{ReLU}(\textrm{Conv}(\mathbf{E}_w(\bw_{t-4:t-1})))
\end{aligned}
\end{equation}
where $\mathbf{E}_w$ gives the word embeddings and
$W_x\in\mathbb{R}^{|\mcX|\times h}$ is weight-tied to the embeddings.

For the feedforward model we use a batch size of 128 and a bptt length of 64, as we found the model needed a larger batch size to train.
For the LSTM, we use a batch size of 16 and a BPTT length of 32.
For both baseline models we use a learning rate of 1e-3 and a dropout rate of 0.3 on the activations in the model.
Both models use a hidden dimension of 256 throughout.
These same hyperparameters were applied on both \texttt{Penn Treebank} and \texttt{Wikitext-2}.

For the HMMs we use a batch size of 16 and a BPTT length of 32.
We use state dropout with $\lambda = 0.5$.
We use a learning rate of 1e-2 for \texttt{Penn Treebank},
and a learning rate of 1e-3 for \texttt{Wikitext-2}.

All weights are initialized with the Kaiming uniform initialization.

\section{HMM Parameterization}
We use the following residual network:
\begin{equation}
\label{eqn:res}
\begin{aligned}
f_i(E) &= g_i(\textrm{ReLU}(EW_{i1}))\\
g_i(D) &= \textrm{LayerNorm}(\textrm{ReLU}(DW_{i2}) + D)
\end{aligned}
\end{equation}
with $i \in \set{\textrm{out},\textrm{in},\textrm{emit}}$.

For the factored state embeddings in Sec.~\ref{sec:methods}, we
apply $f$ to obtain
\begin{equation}
\begin{aligned}
\mathbf{H}_\textrm{out} &= f_\textrm{out}(f_o([\mathbf{E}_m,\mathbf{E}_z]))\\
\mathbf{H}_\textrm{in} &= f_\textrm{in}(f_i([\mathbf{E}_m,\mathbf{E}_z]))\\
\mathbf{H}_\textrm{emit} &= f_\textrm{emit}(f_e([\mathbf{E}_m,\mathbf{E}_z]))
\end{aligned}
\end{equation}

\section{Emission constraint ablation}
The top section of Tbl.~\ref{tbl:constraint-ablation}
shows that the performance is
insensitive to the number of Brown clusters with $|\mcZ|=2^{14}$.
However, in the middle section,
the model with $|\mcZ|=2^{10}$ is sensitive to the number of Brown clusters.
With $M=4$ blocks, the block-sparse HMM matches the unconstrained HMM.
However, when $M=8$, the block-sparse model underperforms.
This implies that there may be a loss in performance due to the emission constraints.

We additionally compare the partitions induced by Brown clustering with a uniform
constraint that samples subsets of states of size $n$
independently and uniformly from $\mcZ$.
This foregoes a partitioning, which makes it difficult to apply state dropout.
We therefore apply a version of dropout that does not have block structure
and zeroes out elements of the transition matrix randomly.
In the bottom section of Tbl.~\ref{tbl:constraint-ablation},
we find that models with uniform constraints
are consistently outperformed by models with Brown cluster constraints
as measured by validation perplexity.
The models with uniform constraints also had poor validation perplexities
despite better training perplexities, a symptom of overfitting.

In conclusion,
we find the Brown cluster emission constraints to achieve reasonable performance
in HMMs with large state spaces.
We also observe that model performance is sensitive to the emission constraints,
motivating future work towards exploring learning emission constraints
while keeping inference tractable. 


\begin{table}[h]
\centering
\begin{tabular}{lllll}
\toprule
Constraint & $|\mcZ|$ & $|\mcC_x|$ & $m$ & Val PPL\\
\midrule
Brown & 16384 & 512 & 32  & 137\\
Brown & 16384 & 256 & 64  & 138\\
Brown & 16384 & 128 & 128 & 134\\
Brown & 16384 & 64  & 256 & 136\\
\midrule
None  & 1024 & - & - & 180\\
Brown & 1024 & 256 & 4 & 182\\
Brown & 1024 & 128 & 8 & 194\\
\midrule
Uniform    & 8192    & 128    & -   & 150\\
Brown      & 8192    & 128    & 64  & 142\\
Uniform    & 16384   & 128    & -   & 146\\
Brown      & 16384   & 128    & 128 & 136\\
\bottomrule
\end{tabular}
\caption{\label{tbl:constraint-ablation}
Perplexities on the \texttt{Penn Treebank} dataset.
We ablate the effect of the number of Brown clusters,
examine whether there may be a drop in performance due to the emission sparsity constraint,
and compare the Brown cluster constraint to a uniform baseline.
All models have 0.5 state dropout, except for the 1k state HMMs,
which have no dropout.
We use $m$ to indicate the number of clusters.
}
\end{table}

\section{}
We additionally ablate the factored state embeddings,
and find that the performance of state embeddings with
independent parameters is similar to a model with factored embeddings.
We additionally found that if the number of clusters is too small
(i.e. 64 or 32 as opposed to 128)
while keeping the total number of hidden states fixed to 16k,
performance on validation drops to 143 perplexity.

\end{document}
